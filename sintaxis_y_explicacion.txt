---------------------------------------------------------------
//BUSCAR OBJETOS EN LA ESCENA
Buscar actores cuando el juego se ejecuta es algo fundamental, pero bastante lento asi que usar con precaucion,
para buscar objetos en la escena hay que importar una libreria

#include "Kismet/GameplayStatics.h"


Luego buscamos por clase o por clase con tag.
importante poner "UGameplayStatics::"

////para buscar de actores que estan en la escena con tag
TArray<AActor* > TodosLosAcotres;//declaro variable
UGameplayStatics::GetAllActorsOfClassWithTag(GetWorld(), AActor::StaticClass(), TEXT("objeto"), TodosLosAcotres);//uso variable como parametro

////para buscar un solo actor por clase
TSubclassOf<class ADatosGlobales> enEscena;//declaro variable
UGameplayStatics::GetActorOfClass(GetWorld(), enEscena);//uso variable como parametro
-------------------------------------------------------------

-------------------------------------------------------------
INPUTS
Tiene que heredar de Pawn, y sino es el player prinncipal hay que activarlo.
Los inputs tendrian que poder activarse desde cualquier lado

tenemos que usar el include
#include "Components/InputComponent.h"
#include "Input.h"

//en begin play
EnableInput(GetWorld()->GetFirstPlayerController());
//the enable input used here means i dont have to enable auto receive input in the editor window
UInputComponent* myInputComp = this->InputComponent;  //InputComponent variable is from AActor.h
//check that it is valid before calling
//i.e. not null.  
if (myInputComp)
{
  SetupMyPlayerInputComponent(myInputComp);
}


La funci칩n que se usa en .h
virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;


// la funci칩n que se usa en .Cpp
void ACar::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
	
	PlayerInputComponent->BindAction("derecha", EInputEvent::IE_Pressed, this, &ACar::MoverIzquierda);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

MENSAJE POR PANTALLA.

//Sino funciona incluir.
#include "Engine/GameEngine.h".

//se puede hacer un define abajo de las importaciones de las librerias// no funciona
#define Print(x) if(GEngine){GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Yellow, TEXT(x) );}//no funciona

Asi se imprimiria concatenando numeros
Print("Puntaje de gameMode, %f ", ReglasJuego->superVelocidad);

//Sino imprimir directo
GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, FString::Printf(TEXT("TEXT")));

//mensaje en consola
uelog
UE_LOG(LogTemp, Display, TEXT("Your message"));

//diferentes tipos de datos compa침ados
int intVar = 5;
float floatVar = 3.7f;
FString fstringVar = "an fstring variable";
UE_LOG(LogTemp, Warning, TEXT("Text, %d %f %s"), intVar, floatVar, *fstringVar );

/////////////////////////////////////////////////////////////////////////////////////////////////////

OBTENER EL GAME MODE

en .H declaro el puntero a la clase gamemode con su correspondiente nombre usando forward declaration
class AReglasJuego* ReglasJuego;//puntero al game mode principal0.


incluyo en .CPP
#include "Engine/World.h" //incluimos el mundo
#include "ReglasJuego" //incluimos la clase game mode personal

y en la funci칩n beginPlay
ReglasJuego = Cast<AReglasJuego>(GetWorld()->GetAuthGameMode());

/////////////////////////////////////////////////////////////////////////////
BLUEPRINT COMPONENTE ROOT

en .h
UPROPERTY(VisibleAnywhere)
USceneComponent * root; //root de todo el blueprint

en el contructor de .CPP
root = CreateDefaultSubobject<USceneComponent>(TEXT("CarRoot"));//creo el componente

RootComponent = root;//agrego como root

//////////////////////////////////////////////////////////////////////////////